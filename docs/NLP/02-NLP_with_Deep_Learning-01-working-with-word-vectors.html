
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="ipynb_website:version" content="0.9.4" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" type="text/css" href="../css/jt.css">
<link rel="stylesheet" type="text/css" href="../css/readable.css">
<link rel="stylesheet" type="text/css" href="../css/toc2.css">

<link href="../site_libs/jqueryui-1.11.4/jquery-ui.css">
<link rel="stylesheet" href="../site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<link rel="stylesheet" href="../site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.9.1/jquery-ui.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<link rel="stylesheet"
      href="../site_libs/highlightjs/null.min.css"
      type="text/css" />

<script src="../site_libs/highlightjs/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>

<script src="../js/doc_toc.js"></script>
<script src="../js/docs.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": {
            preferredFont: "TeX",
            availableFonts: ["TeX"],
            styles: {
                scale: 110,
                ".MathJax_Display": {
                    "font-size": "110%",
                }
            }
        }
    });
</script>
<script>
function filterDataFrame(id) {
    var input = document.getElementById("search_" + id);
    var filter = input.value.toUpperCase();
    var table = document.getElementById("dataframe_" + id);
    var tr = table.getElementsByTagName("tr");
    // Loop through all table rows, and hide those who don't match the search query
    for (var i = 1; i < tr.length; i++) {
        for (var j = 0; j < tr[i].cells.length; ++j) {
            var matched = false;
            if (tr[i].cells[j].innerHTML.toUpperCase().indexOf(filter) != -1) {
                tr[i].style.display = "";
                matched = true
                break;
            }
            if (!matched)
                tr[i].style.display = "none";
        }
    }
}
function sortDataFrame(id, n, dtype) {
    var table = document.getElementById("dataframe_" + id);
    var tb = table.tBodies[0]; // use `<tbody>` to ignore `<thead>` and `<tfoot>` rows
    var tr = Array.prototype.slice.call(tb.rows, 0); // put rows into array
    if (dtype === 'numeric') {
        var fn = function(a, b) { 
            return parseFloat(a.cells[n].textContent) <= parseFloat(b.cells[n].textContent) ? -1 : 1;
        }
    } else {
        var fn = function(a, b) {
            var c = a.cells[n].textContent.trim().localeCompare(b.cells[n].textContent.trim()); 
            return c > 0 ? 1 : (c < 0 ? -1 : 0) }
    }
    var isSorted = function(array, fn) {
        if (array.length < 2)
            return 1;
        var direction = fn(array[0], array[1]); 
        for (var i = 1; i < array.length - 1; ++i) {
            var d = fn(array[i], array[i+1]);
            if (d == 0)
                continue;
            else if (direction == 0)
                direction = d;
            else if (direction != d)
                return 0;
            }
        return direction;
    }
    var sorted = isSorted(tr, fn);
    if (sorted == 1 || sorted == -1) {
        // if sorted already, reverse it
        for(var i = tr.length - 1; i >= 0; --i)
            tb.appendChild(tr[i]); // append each row in order
    } else {
        tr = tr.sort(fn);
        for(var i = 0; i < tr.length; ++i)
            tb.appendChild(tr[i]); // append each row in order
    }
}
</script>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');
  // mark it active
  menuAnchor.parent().addClass('active');
  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>
<div class="container-fluid main-container">
<!-- tabsets -->
<script src="../site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>



<title>Nathaniel Dake Blog</title>

<style type = "text/css">
body {
  font-family: "sans-serif";
  padding-top: 66px;
  padding-bottom: 40px;
}
</style>
</head>

<body>
<div tabindex="-1" id="notebook" class="border-box-sizing">
<div class="container" id="notebook-container">

<!-- code folding -->

<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">Nathaniel Dake Blog</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
<li>
  <a href="../Deep_Learning.html">Deep Learning</a>
</li>
        
<li>
  <a href="../AI.html">AI</a>
</li>
        
<li>
  <a href="../Machine_Learning.html">Machine Learning</a>
</li>
        
<li>
  <a href="../NLP.html">NLP</a>
</li>
        
<li>
  <a href="../Mathematics.html">Mathematics</a>
</li>
        
<li>
  <a href="../Projects.html">Projects</a>
</li>
        
<li>
  <a href="../Book_Reviews.html">Book Reviews</a>
</li>
        
      </ul>
        
<ul class="nav navbar-nav navbar-right">
<li>
   <a href="https://github.com/NathanielDake/nathanieldake.github.io"> source </a>
</li>
</ul>
        
      </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="2.-Working-With-Word-Vectors">2. Working With Word Vectors<a class="anchor-link" href="#2.-Working-With-Word-Vectors">&#182;</a></h1><p>In the introduction section we went over some very basic NLP techniques, and more importantly gained an understanding for how to apply <em>basic</em> machine learning models and APIs to the a problem revolving around text data.</p>
<p>One of the things that we went over was the <strong>term-document matrix</strong>, and how it could be utilized in our process of converting text data to numerical data, so a model can understand it. Well, one of the things that we did not discuss is there is a slight problem with that method, namely its simple counting process. One of the things that tends to happen is that words such as "a", "the", "and", "in", "to", etc, have a high count for ALL documents, no matter what the category is! This is a very large amount of noise that will often overshadow the meaningful words.</p>
<p>These words are known as <strong>stopwords</strong> and one common technique is to just remove them from the dataset before doing any machine learning.</p>
<h3 id="1.1-TF-IDF">1.1 TF-IDF<a class="anchor-link" href="#1.1-TF-IDF">&#182;</a></h3><p>However, there is another technique that we can utilize: <strong>Term Frequency-Inverse Document Frequency</strong>, (TF-IDF). We will not go into the full details of TF-IDF, however, the jist is as follows: We know that words that appear in many documents are probably less meaningful. With this in mind, we can weight each vector component (in this case a word) by something related to how many documents that word appears in. So, intuitively speaking, we may do something like:</p>
<p>$$\frac{\text{raw word count}}{\text{document count}}$$</p>
<p>So, the numerator tells us <em>how many times does this word appear in this document</em>, and the denominator tells us <em>how many documents does this word appear in, in total</em>. Now, in practice we do some transformations on these, like taking the log count, smoothing, and so on. However, the specific implementation isn't nearly as important for this course as is the general understand behind the process.</p>
<h3 id="1.2-Key-Point">1.2 Key Point<a class="anchor-link" href="#1.2-Key-Point">&#182;</a></h3><p>One of the most important things to keep in mind during all subsequent posts is that no matter what technique we are using, we are always interested in a matrix of size $(V x D)$, where $V$ is the vocabulary size (the number of total words), and $D$ is the vector dimensionality, which is we are doing something like counting up the total number of times a word appears in a set of books, $D$ is the total number of books.</p>
<h3 id="1.3-Word-Embeddings">1.3 Word Embeddings<a class="anchor-link" href="#1.3-Word-Embeddings">&#182;</a></h3><p>A final thing to note, we are going to encounter the term <strong>Word-Embedding</strong> quite a bit. This is just a fancy word for an old and relatively straight forward concept. A word-embedding is just a fancy name for a feature vector that represents a word. In other words, we can take a categorical object-a word in this case-and then map this object to a list of numbers (in other words, a vector). We say that we have embedded this word into a vector space, and that is why we call them word embeddings.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="2.-Word-Analogy">2. Word Analogy<a class="anchor-link" href="#2.-Word-Analogy">&#182;</a></h1><p>One of the most popular applications of word embeddings is <strong>word analogies</strong>. This is where the famous <code>king - man = queen - woman</code> comes from.</p>
<p><img src="https://drive.google.com/uc?id=1mlFNZ-GeyzawODRG4Fl0p05fXPSBwOLp" width="700"></p>
<p>So, we are now going to focus on two main questions:</p>
<ol>
<li>What are word analogies?</li>
<li>How can we calculate them?</li>
</ol>
<p>First, however, a few examples. We can start with:</p>
<blockquote><p>King - Queen ~= Prince - Princess</p>
</blockquote>
<p>Above on each side, we have a male member of the royal family minus a female member of the royal family, who is from the same generation.</p>
<blockquote><p>France - Paris ~= Germany - Berlin</p>
</blockquote>
<p>Now, on each side we have a country minus a famous city from that country.</p>
<blockquote><p>Japan - Japanese ~= China - Chinese</p>
</blockquote>
<p>Here, we have a country minus the term used to refer to the people of that country.</p>
<blockquote><p>Brother - Sister ~= Uncle - Aunt</p>
</blockquote>
<p>Now, we have a male member of the family, subtracting a close female member of the family.</p>
<blockquote><p>Walk - Walking ~= Swim - Swimming</p>
</blockquote>
<p>Finally, we can see that we were able to learn something about verb tense.</p>
<h3 id="2.1-Visualing-Analogies">2.1 Visualing Analogies<a class="anchor-link" href="#2.1-Visualing-Analogies">&#182;</a></h3><p>So, how can we actually visualize these analogies? As usual, it is very helpful to think of things geometrically. First, recall that word embedding just means word vector. In other words, if we have a grid, each word is just represented by a dot on the grid. So, what will happen when subtracting one vector from another vector? Well, of course that will just yield the vector between the two vectors. If we can say that the difference of the two vectors on the left is approximately equal to the two vectors on the right, then we know that the two difference vectors are approximately the same.</p>
<p>Now, we know that a vector has two components: a direction and a magnitude. So, when we say that these two vectors are approximately the same, what we are really saying is that their magnitude and direction are very close to one another. This can be visualized below.</p>
<p><img src="https://drive.google.com/uc?id=1toGKPnF6d51GBxUB15w0wYI6PDyZc2oU" width="300"></p>
<h3 id="2.2-How-to-find-analogies?">2.2 How to find analogies?<a class="anchor-link" href="#2.2-How-to-find-analogies?">&#182;</a></h3><p>With that said, how do we actually we find word analogies? Well, we know that their are four words in every analogy. So, what we can do is take three of these words and try to find the fourth word. So, we have an input of three words, and an output of the fourth word. Notice that we because we are dealing entirely with vectors, we can just rearrange our equation as follows:</p>
<p>$$\text{King - Man = ? - Woman}$$</p>
<p>$$\downarrow$$</p>
<p>$$\text{King - Man + Woman = ?}$$</p>
<p>We know that the $?$ is representing <code>Queen</code>, however we will refer to it as <code>SomeVector</code> for the time being.</p>
<p>$$\text{King - Man + Woman = SomeVector}$$</p>
<p>So, our job is to find the word that is most closely associated with <code>SomeVector</code>. We will do this utilizing <em>distance</em>. In pseudocode this may look like:</p>

<pre><code>closest_distance = infinity
best_word = None
test_vector = king - man + woman
for word, vector in vocabulary:
    distance = get_distance(test_vector, vector)
    if distance &lt; closest_distance:
        closest_distance = distance
        best_word = word</code></pre>
<p>Note that utilizing a <code>for</code> loop will be very slow, and we will of course want to vectorize this process utilizing <code>numpy</code>.</p>
<p>Now, we did not define <code>get_distance</code> in the above pseudocode. We have a variety of options when deciding how to calculate distanc. Sometimes, we will simply use <em>Euclidean Distance</em>:</p>
<p>$$\text{Euclidean Distance: } ||a - b||^2$$</p>
<p>It is also common to use the <em>cosine distance</em>:</p>
<p>$$\text{Cosine Distance: } cosine\_distance(a, b) = \frac{1 - a^Tb}{||a|| \; ||b||}$$</p>
<p>In this later form, since only the angle matters, because:</p>
<p>$$a^Tb = ||a|| \; ||b|| cos(a,b)$$</p>
<p>During training we normalize all of the word vectors so that their length is 1:</p>
<p>$$cos(0) = 1, \; cos(90) = 0, \; cos(180) = -1$$</p>
<p>When two vectors are closer, $cos(\theta)$ is bigger. So, we want our distance to be:</p>
<p>$$\text{Distance} = 1 - cos(\theta)$$</p>
<p>At this point we can say that all of the word embeddings lie on the unit sphere.</p>
<h3 id="2.3-Why-is-this-so-cool?">2.3 Why is this so cool?<a class="anchor-link" href="#2.3-Why-is-this-so-cool?">&#182;</a></h3><p>One pretty interesting fact about neural word embedding algorithms is that <em>they can find these analogies at all</em>. Once we have covered these algorithms, specifically <em><strong>word2vec</strong></em> and <em><strong>GloVe</strong></em>, it will become clear that these algorithms have no concept of analogies; in other words, what they want to optimize is totally unrelated to word analogies. So, the fact that word analogies suddenly emerge out of the training process is very intruiging. Remember, in all cases we are still dealing with a $VxD$ word embedding matrix. This is the case whether we are just using raw word counts, TF-IDF, or word2vec. Yet, raw word counts and TF-IDF do <em>not</em> give us good analogies. So, the fact that good word analogies emerge from the model and training process of word2vec is a very interesting research area.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span> 
</pre></div>

</div>
</div>
</div>

</div>
<hr>
&copy; 2018 Nathaniel Dake

</div>
</div>
</body>
</html>
