
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="ipynb_website:version" content="0.9.4" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" type="text/css" href="../css/jt.css">
<link rel="stylesheet" type="text/css" href="../css/readable.css">
<link rel="stylesheet" type="text/css" href="../css/toc2.css">

<link href="../site_libs/jqueryui-1.11.4/jquery-ui.css">
<link rel="stylesheet" href="../site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<link rel="stylesheet" href="../site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.9.1/jquery-ui.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<link rel="stylesheet"
      href="../site_libs/highlightjs/null.min.css"
      type="text/css" />

<script src="../site_libs/highlightjs/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>

<script src="../js/doc_toc.js"></script>
<script src="../js/docs.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": {
            preferredFont: "TeX",
            availableFonts: ["TeX"],
            styles: {
                scale: 110,
                ".MathJax_Display": {
                    "font-size": "110%",
                }
            }
        }
    });
</script>
<script>
function filterDataFrame(id) {
    var input = document.getElementById("search_" + id);
    var filter = input.value.toUpperCase();
    var table = document.getElementById("dataframe_" + id);
    var tr = table.getElementsByTagName("tr");
    // Loop through all table rows, and hide those who don't match the search query
    for (var i = 1; i < tr.length; i++) {
        for (var j = 0; j < tr[i].cells.length; ++j) {
            var matched = false;
            if (tr[i].cells[j].innerHTML.toUpperCase().indexOf(filter) != -1) {
                tr[i].style.display = "";
                matched = true
                break;
            }
            if (!matched)
                tr[i].style.display = "none";
        }
    }
}
function sortDataFrame(id, n, dtype) {
    var table = document.getElementById("dataframe_" + id);
    var tb = table.tBodies[0]; // use `<tbody>` to ignore `<thead>` and `<tfoot>` rows
    var tr = Array.prototype.slice.call(tb.rows, 0); // put rows into array
    if (dtype === 'numeric') {
        var fn = function(a, b) { 
            return parseFloat(a.cells[n].textContent) <= parseFloat(b.cells[n].textContent) ? -1 : 1;
        }
    } else {
        var fn = function(a, b) {
            var c = a.cells[n].textContent.trim().localeCompare(b.cells[n].textContent.trim()); 
            return c > 0 ? 1 : (c < 0 ? -1 : 0) }
    }
    var isSorted = function(array, fn) {
        if (array.length < 2)
            return 1;
        var direction = fn(array[0], array[1]); 
        for (var i = 1; i < array.length - 1; ++i) {
            var d = fn(array[i], array[i+1]);
            if (d == 0)
                continue;
            else if (direction == 0)
                direction = d;
            else if (direction != d)
                return 0;
            }
        return direction;
    }
    var sorted = isSorted(tr, fn);
    if (sorted == 1 || sorted == -1) {
        // if sorted already, reverse it
        for(var i = tr.length - 1; i >= 0; --i)
            tb.appendChild(tr[i]); // append each row in order
    } else {
        tr = tr.sort(fn);
        for(var i = 0; i < tr.length; ++i)
            tb.appendChild(tr[i]); // append each row in order
    }
}
</script>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');
  // mark it active
  menuAnchor.parent().addClass('active');
  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>
<div class="container-fluid main-container">
<!-- tabsets -->
<script src="../site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>



<title>Nathaniel Dake Blog</title>

<style type = "text/css">
body {
  font-family: "sans-serif";
  padding-top: 66px;
  padding-bottom: 40px;
}
</style>
</head>

<body>
<div tabindex="-1" id="notebook" class="border-box-sizing">
<div class="container" id="notebook-container">

<!-- code folding -->

<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">Nathaniel Dake Blog</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
<li>
  <a href="../Deep_Learning.html">Deep Learning</a>
</li>
        
<li>
  <a href="../AI.html">AI</a>
</li>
        
<li>
  <a href="../Machine_Learning.html">Machine Learning</a>
</li>
        
<li>
  <a href="../NLP.html">NLP</a>
</li>
        
<li>
  <a href="../Mathematics.html">Mathematics</a>
</li>
        
<li>
  <a href="../Projects.html">Projects</a>
</li>
        
<li>
  <a href="../Book_Reviews.html">Book Reviews</a>
</li>
        
      </ul>
        
<ul class="nav navbar-nav navbar-right">
<li>
   <a href="https://github.com/NathanielDake/nathanieldake.github.io"> source </a>
</li>
</ul>
        
      </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="6.-Hidden-Markov-Models-with-Theano-and-TensorFlow">6. Hidden Markov Models with Theano and TensorFlow<a class="anchor-link" href="#6.-Hidden-Markov-Models-with-Theano-and-TensorFlow">&#182;</a></h1><p>In the last section we went over the training and prediction procedures of Hidden Markov Models. This was all done using only vanilla numpy the Expectation Maximization algorithm. I now want to introduce how both <code>Theano</code> and <code>Tensorflow</code> can be utilized to accomplish the same goal, albeit by a very different process.</p>
<h2 id="1.-Gradient-Descent">1. Gradient Descent<a class="anchor-link" href="#1.-Gradient-Descent">&#182;</a></h2><p>Hopefully you are familiar with the gradient descent optimization algorithm, if not I recommend reviewing my posts on Deep Learning, which leverage gradient descent heavily (or this <a href="https://www.youtube.com/watch?v=IHZwWFHWa-w">video</a>. With that said, a simple overview is as follows:</p>
<blockquote><p>Gradient descent is a first order optimization algorithm for finding the minimum of a function. To find a local minimum of a function using gradient descent, on takes steps proportional to the negative of the gradient of the function at its current point.</p>
</blockquote>
<p>Visually, this iterative process looks like:</p>
<p><img src="https://drive.google.com/uc?id=1R2zVTj3uo5zmow6vFujWlU-qs9jRF_XG" width="250"></p>
<p>Where above we are looking at a contour plot of a three dimensional bowl, and the center of the bowl is a minimum. Now, the actual underlying mechanics of gradient descent work as follows:</p>
<ol>
<li>Define a model/hypothesis that will be mapping inputs to outputs, or in other words making predictions:</li>
</ol>
<p>$$h_{\theta}(x) = \theta_0 + \theta_1x$$</p>
<p>In this case $x$ is our input and $h(x)$, often thought of as $y$, is our output. We are stating that we believe the ground truth relationship between $x$ and $h(x)$ is captured by the linear combination of $\theta_0 + \theta_1x$. Now, what are $\theta_0$ and $\theta_1$ equal to?</p>
<ol>
<li>Define a <strong>cost</strong> function for which you are trying to find the minimum. Generally, this cost function is defined as some form of <strong>error</strong>, and it will be parameterized by variables related to your model in some way. </li>
</ol>
<p>$$cost = J = (y - h_{\theta}(x))^2$$</p>
<p>Above $y$ refers to the ground truth/actual value of the output, and $h_{\theta}(x)$ refers to that which our model predicted. The difference, squared, represents our cost. We can see that if our prediction is exactly equal to the ground truth value, our cost will be 0. If our prediction is very far off from our ground truth value then our cost will be very high. Our goal is to minimize the cost (error) of our model.</p>
<ol>
<li>Take the <a href="https://en.wikipedia.org/wiki/Gradient"><strong>gradient</strong></a> (multi-variable generalization of the derivative) of the cost function with respect to the parameters that you have control over.</li>
</ol>
<p>$$\nabla J = \frac{\partial J}{\partial \theta}$$</p>
<p>Simply put, we want to see how $J$ changes as we change our model parameters, $\theta_0$ and $\theta_1$.</p>
<ol>
<li>Based on the gradient update our values for $\theta$ with a simple update rule:</li>
</ol>
<p>$$\theta_0 \rightarrow \theta_0 - \alpha \cdot \frac{\partial J}{\partial \theta_0}$$</p>
<p>$$\theta_1 \rightarrow \theta_1 - \alpha \cdot \frac{\partial J}{\partial \theta_1}$$</p>
<ol>
<li>Repeat steps two and three for a set number of iterations/until convergence.</li>
</ol>
<p>After a set number of steps, the hope is that the model weights that were <em>learned</em> are the most optimal weights to minimize prediction error. Now after everything we discussed in the past two posts you may be wondering, how exactly does this relate to Hidden Markov Models, which have been trained via Expectation Maximization?</p>
<h3 id="1.1-Gradient-Descent-and-Hidden-Markov-Models">1.1 Gradient Descent and Hidden Markov Models<a class="anchor-link" href="#1.1-Gradient-Descent-and-Hidden-Markov-Models">&#182;</a></h3><p>Let's say for a moment that our goal that we wish to accomplish is predict the probability of an observed sequence, $p(x)$. And let's say that we have 100 observed sequences at our disposal. It should be clear that if we have a trained HMM that predicts the majority of our sequences are very unlikely, the HMM was probably not trained very well. Ideally, our HMM parameters would be learned in a way that maximizes the probability of observing what we did (this was the goal of expectation maximization).</p>
<p>What may start to become apparent at this point is that we have a perfect cost function already created for us! The total probability of our observed sequences, based on our HMM parameters $A$, $B$, and $\pi$. We can define this mathematically as follows (for the scaled version); in the previous post we proved that:</p>
<p>$$p(x) = \prod_{t=1}^T c(t)$$</p>
<p>Which states that the probability of an observed sequence is equal to the product of the scales at each time step. Also recall that the scale is just defined as:</p>
<p>$$c(t) = \sum_{i=1}^M \alpha'(t,i)$$</p>
<p>With that all said, we can define the cost of a single observed training sequence as:</p>
<p>$$cost = \sum_{t}^{T} log\big(c(t)\big)$$</p>
<p>Where we are using the log to avoid the underflow problem, just as we did in the last notebook. So, we have a cost function which intuitively makes sense, but can we find its gradient with respect to our HMM parameters $A$, $B$, and $\pi$? We absolutely can! The wonderful thing about Theano is that it links variables together via a <a href="http://deeplearning.net/software/theano/extending/graphstructures.html">computational graph</a>. So, cost is depedent on $A$, $B$ and $\pi$ via the following link:</p>
<p>$$cost \rightarrow c(t) \rightarrow alpha \rightarrow A, B, \pi$$</p>
<p>We can take the gradient of this cost function in theano as well, allowing us to then easily update our values of $A$, $B$, and $\pi$! Done iteratively, we hopefully will converge to a nice minimum.</p>
<h3 id="1.2-HMM-Theano-specifics">1.2 HMM Theano specifics<a class="anchor-link" href="#1.2-HMM-Theano-specifics">&#182;</a></h3><p>I would be lying if I said that Theano wasn't a little bit hard to follow at first. For those unfamiliar, representing symbolic mathematical computations as graphs may feel very strange. I have a few walk throughs of Theano in my Deep Learning section, as well as <code>.py</code> files in the source repo. Additionally, the theano <a href="http://deeplearning.net/software/theano/index.html">documentation</a> is also very good. With that said, I do want to discuss a few details of the upcoming code block.</p>
<h4 id="Recurrence-Block-$\rightarrow$-Calculating-the-Forward-Variable,-$\alpha$">Recurrence Block $\rightarrow$ Calculating the Forward Variable, $\alpha$<a class="anchor-link" href="#Recurrence-Block-$\rightarrow$-Calculating-the-Forward-Variable,-$\alpha$">&#182;</a></h4><p>First, I want to discuss the <code>recurrence</code> and <code>scan</code> functions that you will be seeing:</p>

<pre><code>def recurrence_to_find_alpha(t, old_alpha, x):
    """Scaled version of updates for HMM. This is used to 
    find the forward variable alpha.

        Args:
            t:         Current time step, from pass in from scan:
                       sequences=T.arange(1, thx.shape[0])
            old_alpha: Previously returned alpha, or on the first time 
                       step the initial value,
                       outputs_info=[self.pi *  self.B[:, thx[0]], None]
            x:         thx, non_sequences (our actual set of observations)
    """
    alpha = old_alpha.dot(self.A) * self.B[:, x[t]]
    s = alpha.sum()
    return (alpha / s), s

# alpha and scale, once returned, are both matrices with values at each time step
[alpha, scale], _ = theano.scan(
    fn=recurrence_to_find_alpha,
    sequences=T.arange(1, thx.shape[0]),
    outputs_info=[self.pi *  self.B[:, thx[0]], None],    # Initial value of alpha
    n_steps=thx.shape[0] - 1,
    non_sequences=thx,
)

# scale is an array, and scale.prod() = p(x)
# The property log(A) + log(B) = log(AB) can be used 
# here to prevent underflow problem
p_of_x = -T.log(scale).sum()      # Negative log likelihood
cost = p_of_x

self.cost_op = theano.function(
    inputs=[thx],
    outputs=cost,
    allow_input_downcast=True,
)</code></pre>
<p>The above block is where our forward variable $\alpha$ and subsequently the probability of the observed sequence $p(x)$ is found. The process works as follows:</p>
<ol>
<li>The <code>theano.scan</code> function (logically similar to a for loop) is defined with the following parameters:<ul>
<li><code>fn</code>: The recurrence function that the array being iterated over will be passed into.</li>
<li><code>sequences</code>: An array of indexes, $[1,2,3,...,T]$</li>
<li><code>outputs_info</code>: The initial value of $\alpha$</li>
<li><code>non_sequences</code>: Our observation sequence, $X$. This passed in it's entirety to the recurrence function at each iteration.</li>
</ul>
</li>
<li>Our recurrence function, <code>recurrence_to_find_alpha</code>, is meant to calculate $\alpha$ at each time step. $\alpha$ at $t=1$ was defined by <code>outputs_info</code> in <code>scan</code>. This recurrence function essentially is performing the forward algorithm (additionally it incorporates scaling):</li>
</ol>
<p>$$\alpha(1,i) = \pi_iB\big(i, x(1)\big)$$</p>
<p>$$\alpha(t+1, j) = \sum_{i=1}^M \alpha(t,i) A(i,j)B(j, x(t+1))$$</p>
<ol>
<li>We calculate $p(x)$ to be the sum of the log likelihood. This is set to be our <code>cost</code>.</li>
<li>We define a <code>cost_op</code>, which is a theano function that takes in a symbolic variable <code>thx</code> and determines the output <code>cost</code>. Remember, <code>cost</code> is linked to <code>thx</code> via:</li>
</ol>

<pre><code>cost -&gt; scale -&gt; theano.scan(non_sequences=thx)</code></pre>
<h4 id="Update-block-$\rightarrow$-Updating-HMM-parameters-$A$,-$B$,-and-$\pi$">Update block $\rightarrow$ Updating HMM parameters $A$, $B$, and $\pi$<a class="anchor-link" href="#Update-block-$\rightarrow$-Updating-HMM-parameters-$A$,-$B$,-and-$\pi$">&#182;</a></h4><p>The other block that I want to touch on is the update block:</p>

<pre><code>pi_update = self.pi - learning_rate * T.grad(cost, self.pi)
pi_update = pi_update / pi_update.sum()

A_update = self.A - learning_rate*T.grad(cost, self.A)
A_update = A_update / A_update.sum(axis=1).dimshuffle(0, 'x')

B_update = self.B - learning_rate*T.grad(cost, self.B)
B_update = B_update / B_update.sum(axis=1).dimshuffle(0, 'x')

updates = [
    (self.pi, pi_update),
    (self.A, A_update),
    (self.B, B_update),
]

train_op = theano.function(
    inputs=[thx],
    updates=updates,
    allow_input_downcast=True
)

costs = []
for it in range(max_iter):
    for n in range(N):
        # Looping through all N training examples
        c = self.get_cost_multi(X, p_cost).sum()
        costs.append(c)
        train_op(X[n])</code></pre>
<p>The update block functions as follows:</p>
<ol>
<li>We have <code>cost</code> that was defined symbolically and linked to <code>thx</code>. We can define <code>pi_update</code>  as <code>pi_update = self.pi - learning_rate * T.grad(cost, self.pi)</code>. </li>
<li>This same approach is performed for $A$ and $B$. </li>
<li>We then create a theano function, <code>train_op</code> which takes in <code>thx</code>, our symbolic input, and with perform updates via the <code>updates=updates</code> kwarg. Specifically, updates takes in a list of tuples, with the first value in the tuple being the variable that should be updated, and the second being the expression with which it should be updated to be. </li>
<li>We loop through all training examples (sequences of observations), and call <code>train_up</code>, passing in <code>X[n]</code> (a unique sequene of observations) as <code>thx</code>.</li>
<li><code>train_op</code> then performs the <code>updates</code>, utilizing <code>thx = X[n]</code> wherever <code>updates</code> depends on <code>thx</code>.</li>
</ol>
<p>This is clearly stochastic gradient descent, because we are performing updates to our parameters $A$, $B$, and $\pi$ for each training sequence. Full batch gradient descent would be if we defined a cost function that was based on all of the training sequences, not only an individual sequence.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="2.-HMM's-with-Theano">2. HMM's with Theano<a class="anchor-link" href="#2.-HMM's-with-Theano">&#182;</a></h2><p>In code, our HMM can be implemented with Theano as follows:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[18]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">theano</span>
<span class="kn">import</span> <span class="nn">theano.tensor</span> <span class="k">as</span> <span class="nn">T</span>

<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">hmm.utils</span> <span class="k">import</span> <span class="n">get_obj_s3</span><span class="p">,</span> <span class="n">random_normalized</span>

<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="o">%</span><span class="k">config</span> InlineBackend.figure_format = &#39;retina&#39;

<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="s2">&quot;husl&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="s2">&quot;talk&quot;</span><span class="p">)</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="s2">&quot;ticks&quot;</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">HMM</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_cost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">print_period</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Train HMM model using stochastic gradient descent.&quot;&quot;&quot;</span>

        <span class="c1"># Determine V, the vocabulary size</span>
        <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># Initialize HMM variables</span>
        <span class="n">pi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span>          <span class="c1"># Initial state distribution</span>
        <span class="n">A0</span> <span class="o">=</span> <span class="n">random_normalized</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>  <span class="c1"># State transition matrix</span>
        <span class="n">B0</span> <span class="o">=</span> <span class="n">random_normalized</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>       <span class="c1"># Output distribution</span>

        <span class="n">thx</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">pi0</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">B0</span><span class="p">)</span>

        <span class="c1"># This is a beauty of theano and it&#39;s computational graph. </span>
        <span class="c1"># By defining a cost function, which is representing p(x), </span>
        <span class="c1"># the probability of a sequence, we can then find the gradient</span>
        <span class="c1"># of the cost with respect to our parameters (pi, A, B). </span>
        <span class="c1"># The gradient updated rules are applied as usual. Note, the </span>
        <span class="c1"># reason that this is stochastic gradient descent is because</span>
        <span class="c1"># we are only looking at a single training example at a time.</span>
        <span class="n">pi_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">pi_update</span> <span class="o">=</span> <span class="n">pi_update</span> <span class="o">/</span> <span class="n">pi_update</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">A_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">-</span> <span class="n">learning_rate</span><span class="o">*</span><span class="n">T</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
        <span class="n">A_update</span> <span class="o">=</span> <span class="n">A_update</span> <span class="o">/</span> <span class="n">A_update</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dimshuffle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>

        <span class="n">B_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">-</span> <span class="n">learning_rate</span><span class="o">*</span><span class="n">T</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>
        <span class="n">B_update</span> <span class="o">=</span> <span class="n">B_update</span> <span class="o">/</span> <span class="n">B_update</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">dimshuffle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>

        <span class="n">updates</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi_update</span><span class="p">),</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">A_update</span><span class="p">),</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="n">B_update</span><span class="p">),</span>
        <span class="p">]</span>

        <span class="n">train_op</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">thx</span><span class="p">],</span>
            <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span>
            <span class="n">allow_input_downcast</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">costs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="c1"># Looping through all N training examples</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cost_multi</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">p_cost</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">train_op</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A learned from training: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;B learned from training: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pi learned from training: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pi</span><span class="o">.</span><span class="n">get_value</span><span class="p">())</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">costs</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Iteration Number&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Cost&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_op</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_cost_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">p_cost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cost</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">p_cost</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">log_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_op</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="c1"># Create theano shared variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

        <span class="c1"># Define input, a vector</span>
        <span class="n">thx</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">ivector</span><span class="p">(</span><span class="s2">&quot;thx&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">recurrence_to_find_alpha</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">old_alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Scaled version of updates for HMM. This is used to find the </span>
<span class="sd">            forward variable alpha.</span>

<span class="sd">            Args:</span>
<span class="sd">                t:         Current time step, from pass in from scan:</span>
<span class="sd">                           sequences=T.arange(1, thx.shape[0])</span>
<span class="sd">                old_alpha: Previously returned alpha, or on the first time step </span>
<span class="sd">                           the initial value, </span>
<span class="sd">                           outputs_info=[self.pi *  self.B[:, thx[0]], None]</span>
<span class="sd">                x:         thx, non_sequences (our actual set of observations)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">old_alpha</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[:,</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">s</span><span class="p">),</span> <span class="n">s</span>

        <span class="c1"># alpha and scale, once returned, are both matrices with values at each time step</span>
        <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
            <span class="n">fn</span><span class="o">=</span><span class="n">recurrence_to_find_alpha</span><span class="p">,</span>
            <span class="n">sequences</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">thx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">outputs_info</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span>  <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">[:,</span> <span class="n">thx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>    <span class="c1"># Initial value of alpha</span>
            <span class="n">n_steps</span><span class="o">=</span><span class="n">thx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">non_sequences</span><span class="o">=</span><span class="n">thx</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># scale is an array, and scale.prod() = p(x)</span>
        <span class="c1"># The property log(A) + log(B) = log(AB) can be used </span>
        <span class="c1"># here to prevent underflow problem</span>
        <span class="n">p_of_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">T</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>      <span class="c1"># Negative log likelihood</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">p_of_x</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cost_op</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">thx</span><span class="p">],</span>
            <span class="n">outputs</span><span class="o">=</span><span class="n">cost</span><span class="p">,</span>
            <span class="n">allow_input_downcast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">thx</span><span class="p">,</span> <span class="n">cost</span>


<span class="k">def</span> <span class="nf">fit_coin</span><span class="p">(</span><span class="n">file_key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Loads data and trains HMM.&quot;&quot;&quot;</span>

    <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">get_obj_s3</span><span class="p">(</span><span class="n">file_key</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="s2">&quot;H&quot;</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()]</span>
        <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Instantiate object of class HMM with 2 hidden states (heads and tails)</span>
    <span class="n">hmm</span> <span class="o">=</span> <span class="n">HMM</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">hmm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">hmm</span><span class="o">.</span><span class="n">get_cost_multi</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Log likelihood with fitted params: &quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># Try the true values</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
    <span class="p">])</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]</span>
    <span class="p">])</span>
    <span class="n">hmm</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">hmm</span><span class="o">.</span><span class="n">get_cost_multi</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Log Likelihood with true params: &quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;coin_data.txt&quot;</span>
    <span class="n">fit_coin</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>A learned from training: 
 [[0.50000007 0.49999993]
 [0.50000005 0.49999995]]
B learned from training: 
 [[0.52666344 0.47333656]
 [0.52666383 0.47333617]]
pi learned from training: 
 [0.50007189 0.49992811]
</pre>
</div>
</div>

<div class="output_area">

<div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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l5qaqszMTJ144on+Lfg3jj0uAAAAAMDawiq4OPfcc32eY/Dgwbr11lv9UI2rqqoqPfvss+b9DTfc0Ow79h0XRzqS9ZtvvtFVV12lO++8U5dffrlvhbYiLBUBAAAAAGsLq+DC6l5//XVzo82UlBSdfvrpRxx/6NAhFRQUmPcxMTG65pprdP7556tXr14qLy/XF198oSeeeEKbNm1SXV2d/u///k9JSUlKS0vzqCZPxzWlsXvEqlgqAgAAAADWRnBhEYZhaNGiReb9lClTmn3HfmPOjh07avHixUpJSTGftW3bVmeffbZOP/103XLLLVq7dq0Mw9A999yjU089VW3d/dbupLCwsIU/yW8LS0UAAAAAwNrC6lQRK3vvvfe0fft2SVLv3r01duzYZt/53e9+p7Vr1+r555/XokWLHEILe9HR0VqwYIE6deokSSouLtZbb73lv+J/w1gqAgAAAADWRseFRaxYscK8vuiiixQZGdnsO5GRkerdu7d69+7d7Nj27dvrD3/4g1544QVJ0kcffaQLL7yw2fd69uzZ7JgjKSoqUl1dnU9zBBJLRQAAAADA2gguLKC6ulobNmww75s7ScRbw4YNM6/z8/M9eicnJ8en70xLS7P0cpM2bVyf0XEBAAAAANbBUhEL+Pjjj1VWViZJGjJkiPr16xeQ74mPjzevG78v3NlsrstFCC4AAAAAwDoILixg7dq15vW4ceNa/H5VVZVqa2ubHVdeXm5e24cY4c55uQhLRQAAAADAOgguLOCjjz4yr88880yP37vxxht1wgkn6Nhjj9W7777b7Pht27aZ1wMHDmxZka0YHRcAAAAAYF0EFyG2Z88eFRQUSJLatWunAQMGePxufHy82UXx3nvvHXFsfX293n77bfN+1KhRXlTbOtFxAQAAAADWRXARYps2bTKvhwwZoogIz/+VnH322eb18uXLtWvXribHLlq0SD/99JMkKTExUWPGjPGi2tbJObig4wIAAAAArIPgIsTsl2+kpKS06N0zzjhDQ4YMkSRVVFTo+uuvdwkvDMPQiy++qAcffNB8lpmZqTbujtMIUywVAQAAAADr4jjUEGvsgpCkTp06tejdiIgIPfDAA7r88st18OBBbdu2TWPHjtU555yjAQMG6ODBg3r//fcdwpE//elPXm0A2pqxVAQAAAAArIvgIsT27NljXnfo0KHF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kydP9veP1CrQcQEAAAAA1sMeFyGQlJSke+65R3fccYcMw9Abb7yhTz/9VOnp6UpMTNTu3bu1du1a7d27V5IUFRWlBx98UL1793aZq3379rrrrrt08803yzAMPfroo3rnnXd0+umnKyIiQh9++KG+/vprc/ycOXPUrVu3oP2svyXR0a7PCC4AAAAAILQILkLkj3/8o6KionTXXXepvLxce/bs0QsvvOAyLiEhQffdd5/OOOOMJuc655xzdP/99+vee+9VZWWltmzZYu5n0ahNmzbKzMzUhRde6O8fpdWg4wIAAAAArIfgIoTOO+88jRo1Si+//LLef/99/fjjjyovL1enTp3Ur18/jRkzRhMmTGj21BFJGj9+vE4++WS98MILeu+997R7927V1dUpOTlZI0eO1FVXXeVwIglcEVwAAAAAgPXYDOcNEQA/SktLU2FhoSSpZ8+e5p4dVlRbK7Vp4/js3nulu+8OTT0AAAAAYHXB+J2PzTmBX0RFSRFO/0fQcQEAAAAAoUVwAdhxXi5CcAEAAAAAoUVwAdghuAAAAAAAayG4AOwQXAAAAACAtRBcAHYILgAAAADAWgguADsEFwAAAABgLQQXgB2CCwAAAACwFoILwA7BBQAAAABYC8EFYIfgAgAAAACsheACsOMcXFRXh6YOAAAAAEADggvADh0XAAAAAGAtBBeAHYILAAAAALAWggvATnS04z3BBQAAAACEFsEFYIeOCwAAAACwFoILwA7BBQAAAABYC8EFYIfgAgAAAACsheACsENwAQAAAADWQnAB2CG4AAAAAABrIbgA7DgHF7W1Un19aGoBAAAAABBcAA6cgwuJrgsAAAAACCWCC8AOwQUAAAAAWAvBBWCH4AIAAAAArIXgArBDcAEAAAAA1kJwAdhxF1xUVwe/DgAAAABAA4ILwA4dFwAAAABgLQQXgB2CCwAAAACwFoILwA7BBQAAAABYC8EFYIfgAgAAAACsheACsBMd7fqM4AIAAAAAQofgArBDxwUAAAAAWAvBBWCH4AIAAAAArIXgArBDcAEAAAAA1kJwAdghuAAAAAAAayG4AOwQXAAAAACAtRBcAHYILgAAAADAWgguADsEFwAAAABgLQQXgB2CCwAAAACwFoILwE5kZMMfe9XVoakFAAAAAEBwAbhw7rqg4wIAAAAAQofgAnBCcAEAAAAA1kFw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puq0007Ttddeq+XLl7doz48tW7Zo9uzZGjNmjIYNG6aTTjpJf/zjH/XYY4+puLjYmx8Jdui4AAAAAIDg8+k41IKCAr3xxhtmaPHUU09p1KhRXs1ls9l0zTXXKDExUbNmzZIkLV26VDNmzFBCQoIvZTZr3rx5Kigo8GmOpUuXerwhaaPS0lJNnz5dGzdudHi+Z88e7dmzRx988IFeeeUVPfLII+revfsR53riiSf02GOPqb6+3nxWXV2tgwcPauvWrXrhhRd0//33a8yYMS2qEb9y7rioqpKqq6Xo6NDUAwAAAADhwKeOixUrVph7WkydOtXr0MLeeeedp4suukiSVFdXp+XLl/s855E8/vjjys7O9mmODRs2aM6cOS16p7q6WlOmTDFDi44dO2rixImaOXOmJkyYoPbt20uSvvzyS02fPl0VFRVNzvX888/rkUceUX19vWw2m0477TT9+c9/1pQpUzRo0CBJ0oEDBzRz5kyOnvWBc8eFxHIRAAAAAAg0n4KLxg04o6OjddVVV/mlIEm64YYbZLPZJClgv2jX1NTovvvu02OPPebTPNnZ2ZoxY4Zqampa9N4zzzyjvLw8SdIxxxyjVatWae7cuZo+fbruv/9+vfnmm0pJSZEkbdq0SU8//bTbefLz880lNW3atNG///1vPfPMM5oxY4ZuvfVWrVy5Utddd52khp85MzNTtbW13v64Ya1jR9dnrMABAAAAgMDyKbjYvn27bDabUlNTFe/ur6O91Lt3bw0aNEiGYWjbtm1+m7dRYWGhMjIylJWV5fUcZWVlyszM1N13393i0KKiokLPPvusJCkqKkqPPvqoy3KY7t2766mnnlJsbKykhq4Kd5uVLly40Pz+adOmKS0tzeHziIgI3Xbbbebzn376Sa+//nqL6kWDgQNdn337bfDrAAAAAIBw4lNw0XiSSK9evfxSjL3GJQ6lpaV+m7OsrEwPPfSQxo4day7R6Natm1JTUz2eo66uTq+88orS09O1bNkySQ2dDqeccorHc6xbt84MIdLT09W3b1+345KSkjRhwgRJUnl5udatW+fweXV1tVatWiWpoevl6quvbvI7b7zxRvN6xYoVHteKXx19tOszggsAAAAACCyfgovGJQdRUT7t8elWu3btJKnF3QxH8uqrr2rhwoWqqqqSJI0YMUJLliwxj2L1RF5enubMmaOS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CwtT48aNNWDAAN14442qVKlSYb4e/NQvv/yi+fPna8OGDTp69KiSk5NVrVo1tWrVSldffbUGDRqk8uXL57mf5ORkzZs3T19//bV27dqlxMRE1apVS5GRkbrhhhvUp0+ffOXp448/1oYNGxQbG6uQkBA1aNBA11xzjW666SZVr169MF8ZfmrFihWaP3++Nm/erLi4OFWuXFn16tVTz549dcMNN6hhw4Z57oNyiOLy66+/6pZbblFqaqoeeugh/f3vf881PWURhRUVFaWYmBiv0+/atcvj+vT0dC1cuFCff/65tm/frrNnz6p69epq1qyZrr32Wl177bUqV867W/pdu3Zp1qxZ+umnn3TkyBGVL19edevWVVRUlG6++WbVrVvX6/z6QoAxxvg6E0BJ++KLL/TMM8/o3LlzHrcHBwfriSee0O23317COUNp9cwzz2jOnDmS5FXgYufOnbr//vt16NChHNMMGjRI48aNy/XGMzk5WU888YS+/vrrHNM0adJEkyZN0sUXX5zHt0BpkZCQoLFjx2rhwoW5pmvQoIEmT56s1q1b55jm0KFDuu+++/Tbb7/lmKZ79+6aOHGiwsLCckxjjNH48eM1Y8aMHNOEh4dr4sSJXgX2UDrEx8frscce07Jly3JMU6FCBY0aNUp33313jmkohygu586d06BBg7R3715JyjNwQVlEYZ0+fVodO3bM13s8BS7OnDmjBx98UD///HOO77vkkks0adKkPIMO77//vl577TWlpqZ63F6lShW98MIL6tevX77yXZIIXKDMWb58ue6//36lp6dLktq3b68uXbpIkn788Udt3LjRSTthwgQNGjTIJ/lE6fHmm29q0qRJzuu8AheHDx/WoEGDdPLkSUlS/fr11adPH4WGhmrHjh1atmyZ88Nyww03aPz48Tnua/To0Vq0aJEke3PQu3dvNWvWTHFxcfr2228VGxsrSapdu7bmzZunOnXqFPr7wrdSU1M1fPhwrVmzRpIUEBCgrl276pJLLlH58uW1b98+LV68WAkJCZKksLAwffLJJx5bkcXHx+vGG2/Uvn37JEm1atXSNddco1q1amnPnj1avHixzp8/L0nq0qWLpkyZkuOTnZdfflnvv/++JCkoKEi9evVS69atdfbsWS1evFgHDx6UJIWEhOiTTz5Ry5Yti/S4oOSlpaXpjjvu0Lp16yRJgYGB6tGjhy6++GIlJSVp48aN2rRpk5P+ySef1F133ZVtP5RDFKdx48bpo48+cl7nFrigLKIorF27VnfeeackqVu3bs59Rm7uuecet9epqakaNmyYNmzYIEkKDQ3VNddcowYNGigmJkbffPONzp49K0lq2bKlPvnkE4WEhHjc98cff6znnnvOed21a1dddtllSkpK0vLly50gXbly5fT+++/nq8VviTJAGRIfH2+6du1qWrZsaVq2bGmmT5+eLc0nn3xiLr74YtOyZUtz6aWXmri4uJLPKEqF5ORk8/zzzzvlKePvxx9/zPV9I0aMcNKOHj3anD9/3m37pk2bTMeOHZ00y5cv97ifr7/+2knTtWtXs3v3brftZ8+eNffee6+T5pFHHincF4ZfmDVrlvN/2qVLF7Np06ZsaeLi4sxtt93mpBs6dKjHfT333HNOmv/7v/8zp0+fdtu+Z88ec9VVVzlpPvroI4/72bx5s9t5c926dW7bk5KSzJgxY5z93HTTTQX89vAnM2bMcP5PO3XqZH799ddsaRYsWGBat25tWrZsadq0aWMOHTqULQ3lEMVl1apVTpnI+Js0aVKO6SmLKArTpk1z/m8XLlxYoH28//77zj4GDBhgjhw54rb92LFj5oYbbnDSvPTSSx73c+jQIXPJJZeYli1bmtatW5uvv/7abXt6err573//6+ynZ8+eJikpqUB5Lm4Mzoky5dNPP3WeQA8YMMCJhroaOnSoE/VMTEx0ouWAq5iYGA0bNkwzZ87M1/u2bdum5cuXS5Lq1aunCRMmqEKFCm5p2rdvr5deesl5PXnyZI/7euutt5zl8ePHZ3uiXqVKFU2aNEn169eXJH3zzTf6/fff85Vf+J9p06Y5y6+88orat2+fLU2NGjX09ttvKzw8XJK0ceNGt9ZkknT8+HF9+umnkqTKlSvr9ddfz9bs+aKLLtJbb72loKAgSdLbb7/tsZnpW2+9JfNnA85//vOfuvzyy922ly9fXs8//7w6dOggSdq8ebNWrFiRr+8N//PBBx84yxMmTFC7du2ypbn++ut1yy23SJJSUlL02WefuW2nHKK4nD59WmPGjJExRsHBwXmmpyyiqGzfvt1ZbtOmTb7fn5ycrClTpkiyLdn++9//ZmsxGx4ernfffVdVqlSRJH300Uc6ceJEtn1NnTrVaSV09913q2/fvm7b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M7Fz505IpVKIxWJcuXJFoUytWrWwcOFC2NnZaX3gwsHBAaNHj8aCBQuQn5+P33//XamMmZkZFi9ejD59+qisx8TEBLt27cKSJUuEPBeq6gOAnj17IiQkRGF2GyIiqhoMXBAREVUxV1dXbNq0CVu2bMGDBw+Qm5sLExMTFBQUKJW1s7PDkSNHcObMGZw9exYJCQl4/fo1CgoKULt2bTRv3hxOTk4YNmwY6tevX2FttLKywsGDBxEZGYlTp07hwYMHyMnJgb6+PkxNTWFjY4P27dvDzc0NNjY2kEgksLS0xJ9//gmxWIxjx47B3d1doc62bdti9+7dWL9+PW7evImcnBwYGxujqKio3O2ztbXFr7/+ilOnTuHMmTPCdRGLxahTpw7s7Ozg6uqKQYMGwcjIqKIui9ZwcHCAh4cHwsPD1ZbV0dHB3LlzMWjQIBw4cADXrl1Deno6DAwM0LBhQzg7O2PkyJGwsrISAkHabtCgQWjbti127tyJS5cuIT09HTVr1kSTJk3g4uKCkSNH4osvvlBbT82aNbFs2TJ4eXnh0KFDiImJQUpKCnJycmBoaIiGDRtCJBLhm2++gaOjYxWcGRERlUZHWllzlhERERERERERfSIm5yQiIiIiIiIircXABRERERERERFpLQYuiIiIiIiIiEhrMXBBRERERERERFqLgQsiIiIiIiIi0loMXBARERERERGR1mLggoiIiIiIiIi0FgMXRERERERERKS1GLggIiIiIiIiIq3FwAURERERERERaS0GLoiIiIiIiIhIazFwQURERERERERai4ELIiIiIiIiItJaDFwQERERERERkdZi4IKIiIiIiIiItBYDF0RERERERESktRi4ICIiIiIiIiKtxcAFEREREREREWktBi6IiIiIiIiISGsxcEFEREREREREWuv/hQWHFxc19sYAAAAASUVORK5CYII=
"
width=535
height=339
>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Log likelihood with fitted params:  1035.345
Log Likelihood with true params:  1059.723
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="3.-HMM's-with-Theano-$\rightarrow$-Optimization-via-Softmax">3. HMM's with Theano $\rightarrow$ Optimization via Softmax<a class="anchor-link" href="#3.-HMM's-with-Theano-$\rightarrow$-Optimization-via-Softmax">&#182;</a></h2><p>One of the challenges of the approach we took is that gradient descent is <em>unconstrained</em>; it simply goes in the direction of the gradient. This presents a problem for us in the case of HMM's. Remember, the parameters of an HMM are $\pi$, $A$, and $B$, and each is a probability matrix/vector. This means that they must be between 0 and 1, and must sum to 1 (along the rows if 2-D).</p>
<p>We accomplished this in the previous section by performing a "hack". Specifically, we renormalized after each gradient descent step. However, this means that we weren't performing <em>real</em> gradient descent, because by renormalizing we are not exactly moving in the direction of the gradient anymore. For reference, the pseudocode looked like this:</p>

<pre><code>pi_update = self.pi - learning_rate * T.grad(cost, self.pi)
pi_update = pi_update / pi_update.sum() # Normalizing to ensure it stays a probability

A_update = self.A - learning_rate*T.grad(cost, self.A)
A_update = A_update / A_update.sum(axis=1).dimshuffle(0, 'x') # Normalize for prob                           
B_update = self.B - learning_rate*T.grad(cost, self.B)
B_update = B_update / B_update.sum(axis=1).dimshuffle(0, 'x') # Normalize for prob

# Passing in normalized updates for pi, A, B. No longer moving in dir of gradient
updates = [
    (self.pi, pi_update),
    (self.A, A_update),
    (self.B, B_update),
]</code></pre>
<p>This leads us to the question: is it possible to use true gradient descent, while still conforming to the constraints that each parameter much be a true probability. The answer is of course yes!</p>
<h3 id="3.1-Softmax">3.1 Softmax<a class="anchor-link" href="#3.1-Softmax">&#182;</a></h3><p>If you are unfamiliar with Deep Learning then you may want to jump over this section, or go through my deep learning posts that dig into the subject. If you are familiar, recall the softmax function:</p>
<p>$$softmax(x)_i = \frac{exp(x_i)}{\sum_{k=1}^K exp(x_k)}$$</p>
<p>Where $x$ is an array of size $K$, and $K$ is the number of classes that we have. The result of the softmax is that all outputs are positive and sum to 1. What exactly does this mean in our scenario?</p>
<h4 id="Softmax-for-$\pi$">Softmax for $\pi$<a class="anchor-link" href="#Softmax-for-$\pi$">&#182;</a></h4><p>Consider $\pi$, an array of size $M$. Supposed we want to parameterize $\pi$, using the symbol $\theta$. We can then assign $\pi$ to be:</p>
<p>$$pi = softmax(\theta)$$</p>
<p>In this way, $\pi$ is like an intermediate variable and $\theta$ is the actual parameter that we will be updating. This ensures that $\pi$ is always between 0 and 1, and sums to 1. At the same time, the values in $\theta$ can be anything; this means that we can freely use gradient descent on $\theta$ without having to worry about any constraints! No matter what we do to $\theta$, $\pi$ will always be between 0 and 1 and sum to 1.</p>
<h4 id="Softmax-for-$A$-and-$B$">Softmax for $A$ and $B$<a class="anchor-link" href="#Softmax-for-$A$-and-$B$">&#182;</a></h4><p>Now, what about $A$ and $B$? Unlike $\pi$, which was a 1-d vector, $A$ and $B$ are matrices. Luckily for us, softmax works well for us here too! Recall that when dealing with data in deep learning (and most ML) that we are often dealing with multiple samples at the same time. Typically an $NxD$ matrix, where $N$ is the number of samples, and $D$ is the dimensionality. We know that the output of our model is usually an $NxK$ matrix, where $K$ is the number of classes. Naturally, because the classes go along the rows, each row must represent a separate probability distribution.</p>
<p>Why is this helpful? Well, the softmax was actually written with this specifically in mind! When you use the softmax it automatically exponentiates every element of the matrix and divides by the row sum. That is exactly what we want to do with $A$ and $B$! Each row of $A$ is the probability of the next state to transition to, and each row of $B$ is the probability of the next symbol to emit. The rows must sum to 1, just like the output predictions of a neural network!</p>
<p>In pseudocode, softmax looks like:</p>

<pre><code>def softmax(A):
    expA = np.exp(A)
    return expA / expA.sum(axis=1, keepdims=True)</code></pre>
<p>We can see this clearly below:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[37]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">])</span>

<span class="n">expA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A exponentiated element wise: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">expA</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Keep dims ensures a column vector (vs. row) output</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">expA</span> <span class="o">/</span> <span class="n">expA</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exponentiated A divided row sum: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>A exponentiated element wise: 
 [[   2.718    7.389]
 [  54.598  148.413]
 [8103.084  148.413]] 

Exponentiated A divided row sum: 
 [[0.269 0.731]
 [0.269 0.731]
 [0.982 0.018]]
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now you may be wondering: Why can't we just perform standard normalization? Why does the exponetial need to be used? For an answer to that I recommend reading up <a href="https://stackoverflow.com/questions/17187507/why-use-softmax-as-opposed-to-standard-normalization">here</a>, <a href="https://stats.stackexchange.com/questions/162988/why-sigmoid-function-instead-of-anything-else/318209#318209">here</a>, and <a href="http://cs231n.github.io/linear-classify/#softmax">here</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="3.2-Update-Discrete-HMM-Code-$\rightarrow$-with-Softmax">3.2 Update Discrete HMM Code $\rightarrow$ with Softmax<a class="anchor-link" href="#3.2-Update-Discrete-HMM-Code-$\rightarrow$-with-Softmax">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[43]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">HMM</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_cost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">print_period</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Train HMM model using stochastic gradient descent.&quot;&quot;&quot;</span>

        <span class="c1"># Determine V, the vocabulary size</span>
        <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">preSoftmaxPi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span> <span class="c1"># initial state distribution</span>
        <span class="n">preSoftmaxA0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span> <span class="c1"># state transition matrix</span>
        <span class="n">preSoftmaxB0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="c1"># output distribution</span>

        <span class="n">thx</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">preSoftmaxPi0</span><span class="p">,</span> <span class="n">preSoftmaxA0</span><span class="p">,</span> <span class="n">preSoftmaxB0</span><span class="p">)</span>

        <span class="c1"># This is a beauty of theano and it&#39;s computational graph. By defining a cost function,</span>
        <span class="c1"># which is representing p(x), the probability of a sequence, we can then find the gradient</span>
        <span class="c1"># of the cost with respect to our parameters (pi, A, B). The gradient updated rules are</span>
        <span class="c1"># applied as usual. Note, the reason that this is stochastic gradient descent is because</span>
        <span class="c1"># we are only looking at a single training example at a time.</span>
        <span class="n">pi_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxPi</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxPi</span><span class="p">)</span>
        <span class="n">A_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxA</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxA</span><span class="p">)</span>
        <span class="n">B_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxB</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxB</span><span class="p">)</span>

        <span class="n">updates</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxPi</span><span class="p">,</span> <span class="n">pi_update</span><span class="p">),</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxA</span><span class="p">,</span> <span class="n">A_update</span><span class="p">),</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxB</span><span class="p">,</span> <span class="n">B_update</span><span class="p">),</span>
        <span class="p">]</span>

        <span class="n">train_op</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">thx</span><span class="p">],</span>
            <span class="n">updates</span><span class="o">=</span><span class="n">updates</span><span class="p">,</span>
            <span class="n">allow_input_downcast</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">costs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="c1"># Looping through all N training examples</span>
                <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cost_multi</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">p_cost</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">train_op</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">costs</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Iteration Number&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Cost&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_op</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_cost_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">p_cost</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cost</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">p_cost</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">log_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_op</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preSoftmaxPi</span><span class="p">,</span> <span class="n">preSoftmaxA</span><span class="p">,</span> <span class="n">preSoftmaxB</span><span class="p">):</span>
        <span class="c1"># Create theano shared variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxPi</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">preSoftmaxPi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxA</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">preSoftmaxA</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxB</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">shared</span><span class="p">(</span><span class="n">preSoftmaxB</span><span class="p">)</span>

        <span class="n">pi</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxPi</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="c1"># softmax returns 1xD if input is a 1-D array of size D</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxA</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">nnet</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preSoftmaxB</span><span class="p">)</span>

        <span class="c1"># Define input, a vector</span>
        <span class="n">thx</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">ivector</span><span class="p">(</span><span class="s2">&quot;thx&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">recurrence_to_find_alpha</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">old_alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Scaled version of updates for HMM. This is used to find the forward variable alpha.</span>

<span class="sd">                Args:</span>
<span class="sd">                    t:         Current time step, from pass in from scan:</span>
<span class="sd">                               sequences=T.arange(1, thx.shape[0])</span>
<span class="sd">                    old_alpha: Previously returned alpha, or on the first time step the initial value,</span>
<span class="sd">                               outputs_info=[pi *  B[:, thx[0]], None]</span>
<span class="sd">                    x:         thx, non_sequences (our actual set of observations)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">old_alpha</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">*</span> <span class="n">B</span><span class="p">[:,</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="n">s</span><span class="p">),</span> <span class="n">s</span>

        <span class="c1"># alpha and scale, once returned, are both matrices with values at each time step</span>
        <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">scale</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span>
            <span class="n">fn</span><span class="o">=</span><span class="n">recurrence_to_find_alpha</span><span class="p">,</span>
            <span class="n">sequences</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">thx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">outputs_info</span><span class="o">=</span><span class="p">[</span><span class="n">pi</span> <span class="o">*</span>  <span class="n">B</span><span class="p">[:,</span> <span class="n">thx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="kc">None</span><span class="p">],</span>    <span class="c1"># Initial value of alpha</span>
            <span class="n">n_steps</span><span class="o">=</span><span class="n">thx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">non_sequences</span><span class="o">=</span><span class="n">thx</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># scale is an array, and scale.prod() = p(x)</span>
        <span class="c1"># The property log(A) + log(B) = log(AB) can be used here to prevent underflow problem</span>
        <span class="n">p_of_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">T</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>      <span class="c1"># Negative log likelihood</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">p_of_x</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cost_op</span> <span class="o">=</span> <span class="n">theano</span><span class="o">.</span><span class="n">function</span><span class="p">(</span>
            <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">thx</span><span class="p">],</span>
            <span class="n">outputs</span><span class="o">=</span><span class="n">cost</span><span class="p">,</span>
            <span class="n">allow_input_downcast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">thx</span><span class="p">,</span> <span class="n">cost</span>


<span class="k">def</span> <span class="nf">fit_coin</span><span class="p">(</span><span class="n">file_key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Loads data and trains HMM.&quot;&quot;&quot;</span>

    <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">get_obj_s3</span><span class="p">(</span><span class="n">file_key</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="s2">&quot;H&quot;</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()]</span>
        <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Instantiate object of class HMM with 2 hidden states (heads and tails)</span>
    <span class="n">hmm</span> <span class="o">=</span> <span class="n">HMM</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">hmm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">hmm</span><span class="o">.</span><span class="n">get_cost_multi</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Log likelihood with fitted params: &quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># Try the true values</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
    <span class="p">])</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]</span>
    <span class="p">])</span>
    <span class="n">hmm</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">hmm</span><span class="o">.</span><span class="n">get_cost_multi</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Log Likelihood with true params: &quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;coin_data.txt&quot;</span>
    <span class="n">fit_coin</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt"></div>




<div class="output_png output_subarea ">
<img src="data:image/png;base64,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VAAAAAAoidtCi/T0dEkyXvNwtGfPHuO6S5cuhT5/6dIlSZLNZnNDdwDcrWBoIeWdIpKT4/leAAAAAFRObgstateuLUlKTU11+swxtLjnnnsKfT7/pJE6deq4oTsA7taypVTgzTAdOiRxkjEAAAAAV7kttGjVqpXsdrsOHjwou91u1E+cOKGffvpJUt4qiu7duzs9e+TIER05ckQ2m02tW7d2V4sA3Cwqyrn2wgvS/w4OAgAAAIBiuS206NatmyQpOTlZCxYskCTl5uZqzpw5kvICi44dOxp7V+Q7d+6cnnvuOeO+qJUYACq+Ll2khx4y144fl3bvtqQdAAAAAJWM20KLwYMHq3r16pKkxYsX6/7771efPn20fft2Y8ywYcOM67Nnz+qVV17Rgw8+qH//+9+SpICAAD344IPuahGAB0yf7lxbudLzfQAAAACofNwWWjRs2FBTp041Xg05efKkfvnlF+Pzu+++2xRI/PLLL/rggw+UkpJiPDNt2jSnlRgAKpcOHaT27c21mBiOPwUAAABQMreFFpI0fPhwvfHGG2rUqJHsdrvsdrv8/Pw0dOhQLVq0yDQ2/9hTu92uG264Qa+88oqGDBnizvYAeMjw4eb7lBRpyxZregEAAABQefi5+wv69++v8PBwJSQkKD09Xc2bNzdOFnFUt25d3X///erUqZMGDx5c6FGpACqn4cMlh61qJElvvy31729NPwAAAAAqB7eHFlLeppuhoaEljsvfsBNA1RIaKnXtKn377bVabKwUHy/99rdWdQUAAACgonPr6yGVxZUrV9S7d2+1adNG3zr+VlVKv/76q3r16qU2bdpo5MiRLj8XHx+vP//5z+revbvat2+vbt266ZFHHtGKFSuUkZHh8jwnT57Uyy+/rIiICN1+++3q1KmTwsPDNXv2bOOYWcAqTz/tXIuMlBxORAYAAAAAE4+stMj3888/a8+ePTpy5IjOnz+vjIwM1axZU/Xr11doaKi6deumVq1aebIlSdLs2bN16tSpMs8zc+ZMnT592uXxWVlZioyMVGxsrKmekpKilJQU7du3T8uXL9eCBQvUpk2bYudat26dnn/+eaeQIyEhQQkJCVq5cqUiIyM1atQo138goBw99FDeEajffXettnevtGOHFBZmXV8AAAAAKi6PhBYJCQl69dVXFR8fX+LYTp06adasWWrZsqX7G5O0cOFCRUdHl3meuLg4rVu3rlTPTJkyxQgsqlevrr59+yo0NFQpKSnatGmTkpOTdfz4cT322GOKiYlRw4YNC50nPj5eU6ZMUW5uriSpY8eO6tatmyTpm2++0f79+5Wdna3Zs2erdu3aGjRoUBl+UuD62GzS3LnOr4N8/DGhBQAAAIDCuT202LFjh5555hmlp6cbR5kWZ9++fRoyZIiioqLUr18/t/WVnZ2tOXPmaPny5WWeKykpSTNmzCjVM3Fxcdq4caMkKSgoSMuWLTPt+zFx4kRNnDhRu3btUlJSkqKiojR//nyneS5fvqznnnvOCCymTp2q0aNHm8ZER0drxowZstvtmjlzpnr27Kl69eqV8qcEyq5nT+n226Xvv79Wi4mRFi6Uqle3ri8AAAAAFZNb97Q4ePCgJkyYoMuXLxuBRYMGDXT//ffr97//vR5//HGNHDlSvXv3Vv369SXlbdqZkZGhyMhI/ec//3FLX4mJiRo5cmS5BBaS9Oyzz+rChQuqVq2ay8+88847xnVUVJTTRqW1atXSggULFBISIikv5Pjxxx+d5lm1apWSk5MlSREREU6BhSQNGzZMY8eOlSSlp6fr3XffdblPoLw98oj5/uJFKS7Oml4AAAAAVGxuCy1yc3MVGRmprKws2Ww2BQcH6+2339bOnTu1YMECTZ06VX/961/17LPPauHChdq9e7fefvttNWrUSFLefg+TJk0yVhCUh7S0NL3++usKDw/X/v37JUn169dX+/btr3vOjz/+WLt27ZIkPfnkky49c+TIER09elSS1LZtW913332FjqtZs6YRNtjtdn3xxRdOY9asWWNcjxs3rsjvHDdunPz9/SVJ69evd2nVC+AOw4c715YsYUNOAAAAAM7cFlps3LhRx48fl81mU9OmTfXZZ5+pT58+stlshY632Wzq06ePPv30U2M/i//+97+KK8e/go2JidHSpUt15coVSVLXrl21evVqtW7d+rrmO378uObOnStJ6tevnyIiIlx67ssvvzSue/ToUexYx8+3bt1q+iw5OdkIP4KCgtSuXbsi5wkMDFTHjh0lSWfPntWhQ4dc6hUob02bSt27m2uxsdKsWdb0AwAAAKDicltosW3bNuP6lVdecXkPhRtvvFFRUVHG/ebNm8u9t6CgIM2aNUvLli1T48aNr2uOnJwcRUZGKiMjQ0FBQXrhhRdcfvbIkSPGdX6QUJQmTZoYf3YJCQlKS0u7rnkkqUOHDsb1gQMHXO4XKG//W0Bk8vzzkgt79QIAAADwIm4LLQ4dOiSbzaZbbrlFnTp1KtWzHTt2VNu2bWW328t1RUBwcLCmTp2qzZs3a+jQoUWu+nDF4sWLjV/8X3rpJd14440uP/vzzz8b1zfffHOJ4/NfmbHb7Tpx4sR1z+MY0Dg+C3jayJFSeLhzvZC9ZgEAAAB4MbeFFikpKZKkNm3aXNfzt9xyiyQZm0yWh379+mn06NEKCAgo0zyHDx/WokWLJElDhgxRr169SvW8488UHBxc4vgGDRoY1+fOnSuXefL//QBW8PWVoqOl224z1zdskMrxP3kAAAAAlZzbjzy93g0f85/z9fUtz3bKLDMzU5MnT1Z2drZCQkI0bdq0Us/x66+/Gtc1a9YscXyNGjWMa8fXQxzncRxTlOoOZ0o6zlOcsLAwl8YV5cyZM2V6HlVX7drS5MmS44E3V69KH38sTZhgWVsAAAAAKhC3hRb16tXT6dOndezYset6Pv+5m266qTzbKrPXXntNCQkJstlsevnll1WrVq1Sz5GVlWVc55/oURzHQMLxWcdrx0CitPMUJzEx0aVxwPUYMkT685+ly5ev1T74gNACAAAAQB63vR7SoUMH2e12HTt2TAcPHizVswcOHNDRo0dls9l0W8H14xbas2ePVqxYIUkaOXKk7r777uuaJ3/1iM1mK/W+Go7jHVehlGUewCq1akkPPWSuff+9tHu3Nf0AAAAAqFjcttKiT58+io2NlSRNnTpVK1euVJ06dUp87uLFi5o6dapxX9r9Itwlvy+73a4WLVro6aefvu65AgICdPHiRdntdmVlZZW42iIzM9O4dlxR4bg3R/4xrtczT3FCQkJcGleUM2fOKCcnp0xzoGobPVpatsxce/FFqcAJvwAAAAC8kNtCi379+mnevHlKTExUQkKCBg8erOnTp6tnz55FPhMfH69Zs2YpMTFRNptNjRs31gMPPOCuFktl5syZOnPmjHx9fTV37lyX9pAoSn5oIUkZGRmlCi1q165tmqewMUVxDDZcfa1l+/btLo0rSlhYGK+YoFg9e0qdO0v/+te12rZteast7rvPur4AAAAAWM9toYWvr6+ioqI0evRo5ebm6tSpU3r88cfVoEEDdezYUY0bN1ZAQIDS09N1+vRpff/998ZpGHa7XX5+foqKiqoQG3F+9dVXWr9+vSSpVatW2rt3r/bu3es07tKlS8b1L7/8on/84x/G/dixY43roKAg/fLLL5KkpKQk1a1bt9jvT0pKMq7r169vmiff2bNnS/w5HMc4PgtYyWaTXnhBKphPstoCAAAAgFtPD7nrrrv05ptvatKkScbGj2fPntWWLVucxtrtdtlsNtntdlWvXl2zZ89Wly5d3Nmeyxx/2T969Kjmzp1b4jMnT540jXMMLVq1amXs85GYmKjWrVsXO9fp06clST4+PmrWrJlRd3zOldUM+fNIUvPmzUscD3hKREThqy2+/FLq3t26vgAAAABYy20bcebr06ePVq1apR49ehjHmNrtdqd/8uvdu3dXdHS0BgwY4O7WLNOmTRvjuqRNSk+cOKHU1FRJUsuWLU2vpbRu3drYUPPw4cMlfu+BAweM61tvvbVUPQPulL/aoqAXX/R4KwAAAAAqELeutMjXtm1bLV26VCdPntSePXt05MgRpaamKi0tTQEBAapXr55uu+023X333aaVBBXF4MGDNXjw4BLHnTp1Sr1795YkdenSRcuXLy90XM+ePRUVFSVJ2rlzp5566qki59y5c6dxfe+995o+CwwM1O233679+/crMTFRP/74Y5GrNlJTU42AJDAwUO3bty/x5wE8qbDVFlu3stoCAAAA8GYeCS3yNWnSRMOGDfPkV1ZILVq0ULt27fTvf/9bhw8fVnx8vH772986jUtPT9f7779v3A8aNMhpTHh4uPbv3y9Jeuutt7RgwYJCv3Pp0qXKzs6WJA0cOFA+Pm5fZAOUis0mzZghDRxorr/4olTIG2UAAAAAvIDlv7n+9NNP+uc//2l1Gx735JNPGtdTpkwxvbohSWlpaZowYYKxV0WvXr3Url07p3mGDh2qRo0aSZI2bdqk+fPnG6/b5IuOjjbCjxo1apj21wAqkgEDpDvuMNfyV1sAAAAA8D7lutLCbrcrJiZGK1eu1BNPPKG+ffuW+ExMTIw++OADNWrUSI8//riGDBlSIU4McbfevXsrPDxcsbGxunDhgkaMGKGwsDC1a9dO58+fV1xcnHGaSr169fRiES/3BwQEaMaMGRo/frxyc3O1aNEibdu2TWFhYfL19dXXX3+tffv2GeOnTZum4OBgj/yMQGnl723BagsAAAAAUjmG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fZ0/cOCA3n33XX3zzTc6efKk/P391bhxY8XHx2vYsGFq3Lix2/V6g8VqtVq9XQTgaZ9++qmmTp2qCxcuFHq9Tp06mjRpkkaOHOnhylBdTZ06VYsXL5Ykt0KL/fv368EHH9SJEyeK7JOQkKBp06YV+6UzOztbkyZN0sqVK4vs07x5c82ZM0etW7cu4V2gusjIyNCTTz6p5cuXF9uvadOmeuWVV9SuXbsi+5w4cUL333+/Dh48WGSf66+/XrNnz1a9evWK7GO1WjVjxgwtXLiwyD6RkZGaPXu2W6Eeqof09HRNmDBBGzduLLJPQECAxo0bp7vvvrvIPnwOUVkuXLighIQEHTlyRJJKDC34LKI8zp49q6uvvrpU9xQWWpw7d04PPfSQvv322yLv69ixo+bMmVNi4LBgwQK9+OKLys3NLfR6SEiIpk+frn79+pWqbk8itECts2nTJj344IPKz8+XJHXq1EndunWTJG3btk07duyw9505c6YSEhK8Uieqj7lz52rOnDn230sKLX7//XclJCQoNTVVkhQdHa0+ffooNDRUP/30kzZu3Gj/P5Zbb71VM2bMKHKs8ePHa8WKFZLMF4PevXsrNjZWKSkpWr16tZKTkyVJDRs21NKlS9WoUaNyv194V25urkaNGqWvvvpKkmSxWHTttdeqY8eO8vf319GjR7V27VplZGRIkurVq6cPPvig0Nlj6enpGjRokI4ePSpJioiIUN++fRUREaHDhw9r7dq1unjxoiSpW7duevPNN4v8q87zzz+vBQsWSJJ8fX3Vs2dPtWvXTufPn9fatWt1/PhxSVJwcLA++OADtWrVqkL/ucDz8vLydOedd+q7776TJPn4+KhHjx5q3bq1srKytGPHDv3444/2/o899pj+8Y9/uIzD5xCVadq0afq///s/++//v737jori6v8H/qYLIiIKimgUC4LYUGJ/JLavLUWNorHFrhFbznksWGLsRsUajSVWYm9JNJZggr0mFLFhQUVQEUFE+rLs74/9cZ8Zli0I4irv1zmcc2fnzt3Z5cOy85lbdCUtGItUWBcvXsTgwYMBAK1btxbXGLoMGzZMtp2dnY2BAwciJCQEAFCmTBl06tQJVapUQWxsLI4fP47Xr18DANzc3LB7926ULl0637Z37tyJ2bNni+1WrVqhcePGyMzMxKlTp0RyztzcHD///HOB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
"
width=534
height=339
>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>


<div class="output_subarea output_stream output_stdout output_text">
<pre>Log likelihood with fitted params:  1030.369
Log Likelihood with true params:  1047.421
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="4.-Hidden-Markov-Models-with-TensorFlow">4. Hidden Markov Models with TensorFlow<a class="anchor-link" href="#4.-Hidden-Markov-Models-with-TensorFlow">&#182;</a></h2><p>I now want to expose everyone to an HMM implementation in TensorFlow. In order to do so, we will need to first go over the <code>scan</code> function in Tensorflow. Just like when dealing with Theano, we need to ask "What is the equivalent of a for loop in TensorFlow?". And why should we care?</p>
<h3 id="4.1-TensorFlow-Scan">4.1 TensorFlow Scan<a class="anchor-link" href="#4.1-TensorFlow-Scan">&#182;</a></h3><p>In order to understand the importance of <code>scan</code>, we need to be sure that we have a good idea of how TensorFlow works, even if only from a high level. In general, with both TensorFlow and Theano, you have to create variables and link them together functionally, but they do not have values until you actually run the functions. So, when you create your $X$ matrix you don't give it a shape; you just say here is a place holder I am going to call $X$ and this is a possible shape for it:</p>

<pre><code>X = tf.placeholder(tf.float32, shape=(None, D))</code></pre>
<p>However, remember that the <code>shape</code> argument is <em>optional</em>, and hence for all intents and purposes we can assume that we do not know the shape of $X$. So, what happens if you want to loop through all the elements of $X$? Well you can't, because we do not know the number of elements in $X$!</p>

<pre><code>for i in range(X.shape[0]): &lt;------- Not possible! We don't know num elements in X
    # ....</code></pre>
<p>In order to write a for loop we must specify the number of times the loop will run. But in order to specify the number of times the loop will run we must know the number of elements in $X$. Generally speaking, we cannot guarantee the length of our training sequences. This is why we need the tensorflow <code>scan</code> function! It will allow us to loop through a tensorflow array without knowing its size. This is similar to how everything else in Tensorflow and Theano works. Using <code>scan</code> we can tell Tensorflow "how to run the for loop", without actually running it.</p>
<p>There is another big reason that the <code>scan</code> function is so important; it allows us to perform <strong>automatic differentiation</strong> when we have sequential data. Tensorflow keeps track of how all the variables in your graph link together, so that it can automatically calculate the gradient for you when you do gradient descent:</p>
<p>$$W(t) \leftarrow W(t-1) - \eta \nabla J\big(W(t-1)\big)$$</p>
<p>The <code>scan</code> function keeps track of this when it performs the loop. The anatomy of the <code>scan</code> function is shown in pseudocode below:</p>

<pre><code>outputs = tf.scan(
    fn=some_function,          # Function applied to every element in sequence 
    elems=thing_to_loop_over   # Actual sequence that is passed in
)</code></pre>
<p>Above, <code>some_function</code> is applied to every element in <code>thing_to_loop_over</code>. Now, the way that we define <code>some_function</code> is very specific and much more strict than that for theano. In particular, it must always take in two arguments. The first element is the last output of the function, and the second element is the next element of the sequence:</p>

<pre><code>def some_function(last_output, element):
    return do_something_to(last_output, element)</code></pre>
<p>The tensorflow scan function returns <code>outputs</code>, which is all of the return values of <code>some_function</code> concatenated together. For example, we can look at the following block:</p>

<pre><code>outputs = tf.scan(
    fn=some_function,          
    elems=thing_to_loop_over  
)

def square(last, current):
    return current * current

# sequence = [1, 2, 3]
# outputs = [1, 4, 9]</code></pre>
<p>If we pass in <code>[1, 2, 3]</code>, then our outputs will be <code>[1, 4, 9]</code>. Now, of course the outputs is still a tensorflow graph node. So, in order to get an actual value out of it we need to run it in an actual session.</p>

</div>
</div>
</div>
<hr>
&copy; 2018 Nathaniel Dake

</div>
</div>
</body>
</html>
