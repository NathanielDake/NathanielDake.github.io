
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="ipynb_website:version" content="0.9.4" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" type="text/css" href="../css/jt.css">
<link rel="stylesheet" type="text/css" href="../css/readable.css">
<link rel="stylesheet" type="text/css" href="../css/toc2.css">

<link href="../site_libs/jqueryui-1.11.4/jquery-ui.css">
<link rel="stylesheet" href="../site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<link rel="stylesheet" href="../site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.9.1/jquery-ui.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="../site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<link rel="stylesheet"
      href="../site_libs/highlightjs/null.min.css"
      type="text/css" />

<script src="../site_libs/highlightjs/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>

<script src="../js/doc_toc.js"></script>
<script src="../js/docs.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
        },
        "HTML-CSS": {
            preferredFont: "TeX",
            availableFonts: ["TeX"],
            styles: {
                scale: 110,
                ".MathJax_Display": {
                    "font-size": "110%",
                }
            }
        }
    });
</script>
<script>
function filterDataFrame(id) {
    var input = document.getElementById("search_" + id);
    var filter = input.value.toUpperCase();
    var table = document.getElementById("dataframe_" + id);
    var tr = table.getElementsByTagName("tr");
    // Loop through all table rows, and hide those who don't match the search query
    for (var i = 1; i < tr.length; i++) {
        for (var j = 0; j < tr[i].cells.length; ++j) {
            var matched = false;
            if (tr[i].cells[j].innerHTML.toUpperCase().indexOf(filter) != -1) {
                tr[i].style.display = "";
                matched = true
                break;
            }
            if (!matched)
                tr[i].style.display = "none";
        }
    }
}
function sortDataFrame(id, n, dtype) {
    var table = document.getElementById("dataframe_" + id);
    var tb = table.tBodies[0]; // use `<tbody>` to ignore `<thead>` and `<tfoot>` rows
    var tr = Array.prototype.slice.call(tb.rows, 0); // put rows into array
    if (dtype === 'numeric') {
        var fn = function(a, b) { 
            return parseFloat(a.cells[n].textContent) <= parseFloat(b.cells[n].textContent) ? -1 : 1;
        }
    } else {
        var fn = function(a, b) {
            var c = a.cells[n].textContent.trim().localeCompare(b.cells[n].textContent.trim()); 
            return c > 0 ? 1 : (c < 0 ? -1 : 0) }
    }
    var isSorted = function(array, fn) {
        if (array.length < 2)
            return 1;
        var direction = fn(array[0], array[1]); 
        for (var i = 1; i < array.length - 1; ++i) {
            var d = fn(array[i], array[i+1]);
            if (d == 0)
                continue;
            else if (direction == 0)
                direction = d;
            else if (direction != d)
                return 0;
            }
        return direction;
    }
    var sorted = isSorted(tr, fn);
    if (sorted == 1 || sorted == -1) {
        // if sorted already, reverse it
        for(var i = tr.length - 1; i >= 0; --i)
            tb.appendChild(tr[i]); // append each row in order
    } else {
        tr = tr.sort(fn);
        for(var i = 0; i < tr.length; ++i)
            tb.appendChild(tr[i]); // append each row in order
    }
}
</script>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');
  // mark it active
  menuAnchor.parent().addClass('active');
  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>
<div class="container-fluid main-container">
<!-- tabsets -->
<script src="../site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>



<title>Nathaniel Dake Blog</title>

<style type = "text/css">
body {
  font-family: "sans-serif";
  padding-top: 66px;
  padding-bottom: 40px;
}
</style>
</head>

<body>
<div tabindex="-1" id="notebook" class="border-box-sizing">
<div class="container" id="notebook-container">

<!-- code folding -->

<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">Nathaniel Dake Blog</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
<li>
  <a href="../Deep_Learning.html">Deep Learning</a>
</li>
        
<li>
  <a href="../AI.html">AI</a>
</li>
        
<li>
  <a href="../Machine_Learning.html">Machine Learning</a>
</li>
        
<li>
  <a href="../NLP.html">NLP</a>
</li>
        
<li>
  <a href="../Mathematics.html">Mathematics</a>
</li>
        
<li>
  <a href="../Projects.html">Projects</a>
</li>
        
<li>
  <a href="../Book_Reviews.html">Book Reviews</a>
</li>
        
      </ul>
        
<ul class="nav navbar-nav navbar-right">
<li>
   <a href="https://github.com/NathanielDake/nathanieldake.github.io"> source </a>
</li>
</ul>
        
      </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="3.-Word-Embeddings-&amp;-Poetry">3. Word Embeddings &amp; Poetry<a class="anchor-link" href="#3.-Word-Embeddings-&amp;-Poetry">&#182;</a></h1><p>This section is intended to serve as an introduction to many of the things that we will touch on in my NLP section pertaining to Deep learning applied to natural language processing.</p>
<p>You will notice that a lot of the RNN examples that we go over, as well as elsewhere on the web will use word sequences as examples. Why is that?</p>
<ol>
<li>Language is an easy topic to comprehend! We speak, read, and write every single day, which makes it rather intuitive to deal with. If you are reading this post, then you are unavoidably using those abilities at this very moment.</li>
<li>RNN's allow for us to no longer treat sentences as <strong>bag-of-words</strong>.</li>
</ol>
<p>Let's focus on number 2 above for a moment. As an example, consider the sentence:</p>
<blockquote><p>"Dogs love cats and I"</p>
</blockquote>
<p>It <em>almost</em> has the correct gramatical structure, but its meaning is most certainly different from the original sentence:</p>
<blockquote><p>"I love dogs and cats"</p>
</blockquote>
<p>So, there is a lot of information (in the quantitative sense) that is thrown away when you use bag-of-words. At this point I am assuming that you have gone through my posts concerning Logistic Regression and intro to NLP, which both go over sentiment analysis and utilize bag-of-words. But in case you have not, let me define bag of words quickly.</p>
<h2 id="1.-Bag-of-Words">1. Bag-of-Words<a class="anchor-link" href="#1.-Bag-of-Words">&#182;</a></h2><p>Consider a the task of sentiment analysis, where we are trying to determine whether a sentence is positive or negative. A positive sentence may be:</p>
<blockquote><p>"Wow, today is a great day!"</p>
</blockquote>
<p>While a negative sentence may be:</p>
<blockquote><p>"Ugh, this movie is absolutely terrible."</p>
</blockquote>
<p>In order to turn each sentence into an input for the classifier, we first start with a vector of 0's of size $V$ (our vocabularly size), so there is an entry for every individual word:</p>

<pre><code>X=[0,0,0,...,0]
len(X) = V</code></pre>
<p>We keep track of which word goes with which index using a dictionary, <code>word2idx</code>. Now, for every word in the sentence, we will set the corresponding index in the vector to <code>1</code>, or perhaps some other frequency measure:</p>

<pre><code>X[idx_of_word] = 1</code></pre>
<p>So, there is a nonzero value for every word that appears in the sentence, and everywhere else zero:</p>

<pre><code>X = [0,1,0,0,...,1]</code></pre>
<p>You can see how given this vector, it wouldn't be easy to determine the correct order of words in the sentence. It isn't completely impossible, if for instance the words are such that their is only one possible ordering, but generally some information is lost.</p>
<p>Now, what happens when you have the two similar sentences:</p>
<blockquote><p>"Today is a good day."</p>
</blockquote>
<p>And:</p>
<blockquote><p>"Today is <em>not</em> a good day."</p>
</blockquote>
<p>Well, these lead to nearly the exact same input vector, except <code>X[not] = 1</code>. This is actually a known drawback of bag-of-words; they are notoriously bad at being able to handle negation. Now, given what we know about RNN's, you can imagine that they may be good at this because they keep state! For instance, if the RNN saw the word <em>not</em>, it may negate everything that comes after it.</p>
<h2 id="2.-Word-Embeddings">2. Word Embeddings<a class="anchor-link" href="#2.-Word-Embeddings">&#182;</a></h2><p>This brings us to a paramount question: How <em>do</em> we treat words in deep learning? The popular method at the moment, which has been able to produce very impressive results, is the use of word embeddings or word vectors. That means that given a vocabulary size $V$, we choose a dimensionality that is much smaller than that, $D$, where $D &lt;&lt; V$, and then map each word vector to somewhere in the $D$ dimensional space. By training a model to do certain things like trying to predict the next word, or try to predict surrounding words, we get vectors (word embeddings) that can be manipulated via arithmetic to produce analogies such as:</p>
<blockquote><p>king - man $\approx$ queen - woman</p>
</blockquote>
<p>The question now is how do we use word embeddings with Recurrent Neural Networks? To accomplish this, we simply create an embedding layer in the RNN. So, the input simply arrives as a one hot encoded word, and in the next layer it becomes a $D$ dimensional vector.</p>
<p><img src="https://drive.google.com/uc?id=1Q2eh1IRL0qxB05p-xb4TJvYSwEHZP7HO" width="500"></p>
<p>This requires the word embedding transformation matrix to be a $VxD$ matrix, where the $i$th row is the word vector for the $i$th word. For reference, all of the matrix dimensions are below:</p>
<p>$$W_e = VxD$$</p>
<p>$$W_x = DxM$$</p>
<p>$$W_h = MxM$$</p>
<p>$$W_o = MxK$$</p>
<p>Two questions will naturally arise at this point. The first being:</p>
<ol>
<li>How do we traing this model?</li>
</ol>
<p>The answer to this is our old friend, gradient descent. We will also see later that when we do Word2Vec that there are some variations on the cross entropy error function that will help us speed up training. The second question is:</p>
<ol>
<li>What are the targets? </li>
</ol>
<p>This is a good question because language models don't necessarily have targets. You can attempt to learn word embeddings on a sentiment analysis task, so your targets could be movie ratings or some kind of movie score. Your targets could also be next word prediction as we discussed before. Again, if we use Word2Vec, the targets will also change based on the particular Word2Vec method we use.</p>
<h2 id="3.-Word-Analogies-with-Word-Embeddings">3. Word Analogies with Word Embeddings<a class="anchor-link" href="#3.-Word-Analogies-with-Word-Embeddings">&#182;</a></h2><p>We are now going to go over how you actually can perform calculations that show that:</p>
<blockquote><p>king - man $\approx$ queen - woman</p>
</blockquote>
<p>It is quite simple, but worth going through so that intuitions can start forming about this entire process.</p>
<p>We can start be rewriting the above as:</p>
<blockquote><p>king - man + woman = ?</p>
</blockquote>
<p>Then there are two main steps:</p>
<ol>
<li>Convert 3 words on the left to their word embeddings. For example: </li>
</ol>

<pre><code>vec(king) = Word_embedding[word2idx["king"]]
v0 = vec(king) - vec(man) + vec(woman)</code></pre>
<p>And <code>v0</code> is just a vector in space with an infinte number of values!</p>
<ol>
<li>We want to then find the "closest" actual word in our vocabulary to the <code>v0</code>, and return that word.</li>
</ol>
<p>Why do we need to do that? Well, the result of <code>vec(king) - vec(man) + vec(woman)</code> just gives us a vector. There is no way to map from vectors to words, since a vector space is continuous, and that would require and infinite number of words. So, the idea is that we just find closest word.</p>
<h3 id="3.1-Distance">3.1 Distance<a class="anchor-link" href="#3.1-Distance">&#182;</a></h3><p>There are various ways of defining distance in the context above. Sometimes, we will simply use <em>Euclidean Distance</em>:</p>
<p>$$\text{Euclidean Distance: } ||a - b||^2$$</p>
<p>It is also common to use the <em>cosine distance</em>:</p>
<p>$$\text{Cosine Distance: } cosine\_distance(a, b) = \frac{1 - a^Tb}{||a|| \; ||b||}$$</p>
<p>In this later form, since only the angle matters, because:</p>
<p>$$a^Tb = ||a|| \; ||b|| cos(a,b)$$</p>
<p>During training we normalize all of the word vectors so that their length is 1:</p>
<p>$$cos(0) = 1, \; cos(90) = 0, \; cos(180) = -1$$</p>
<p>When two vectors are closer, $cos(\theta)$ is bigger. So, we want our distance to be:</p>
<p>$$\text{Distance} = 1 - cos(\theta)$$</p>
<p>At this point we can say that all of the word embeddings lie on the unit sphere.</p>
<h3 id="3.2-Find-the-best-word">3.2 Find the best word<a class="anchor-link" href="#3.2-Find-the-best-word">&#182;</a></h3><p>Once we have our distance function, how do we actually find the closest word? The simplest word is to just look at every word in the vocabulary, and get the distance between each vector and your expression vector. Keep track of the smallest distance and then return that word.</p>

<pre><code>min_dist = Infinity; best_word = ''
for word, idx in word2idx.items():
    v1 = Word_embedding[idx]
    if dist(v0, v1) &lt; min_dist:
        min_dist = dist(v0, v1)
        best_word = word

print("The best word is: ", best_word)</code></pre>
<p>We may want to leave out the words from the left side of the equation, in this case <em>king, man</em>, and <em>woman</em>. Note that we will not be using this on our upcoming poetry data, since it doesn't have the kind of vocabulary we are looking for. We are more interested in things like nouns when we do word analogies. We want to compare kings and queens, men and women, occupations, etc. We will look more at word analogies later on.</p>
<h2 id="4.-Representing-a-Sequence-of-Words-as-a-Sequence-of-Word-Embeddings">4. Representing a Sequence of Words as a Sequence of Word Embeddings<a class="anchor-link" href="#4.-Representing-a-Sequence-of-Words-as-a-Sequence-of-Word-Embeddings">&#182;</a></h2><p>Let's quickly go over one small detail from the upcoming code, that may be slightly confusing. We have a word embedding matrix, $W_e$, which is of size $V x D$ (V = vocabulary size, D = word vector dimensionality):</p>
<p><img src="https://drive.google.com/uc?id=1knUHHjsH714GMPxk82qyFS-QpJF29XlK" width="350"></p>
<p>Note that each row of the word embedding matrix is a <strong>word vector</strong>:</p>
<p><img src="https://drive.google.com/uc?id=1heOWMPjnzAcM1lk5-5o_LH2J2hTpyYKP" width="700"></p>
<p>And we have an input sequence of word indexes of length $T$:</p>
<p><img src="https://drive.google.com/uc?id=1lUFji2r44sX__tdCkHkcjXjWAEbQxW53" width="300"></p>
<p>We would like to get a sequence of word vectors that represent a sentence, which is a $TxD$ matrix. In other words, we want to take the indices from our vector above, and grab the correspond word vectors from the embedding matrix:</p>
<p><img src="https://drive.google.com/uc?id=1IqlwpwkdJs-BjMBhYXOxHqx3rAGYpWjx" width="600"></p>
<p>However, we will need to update the word embeddings via backpropagation, so the $TxD$ matrix we get after grabbing the word vectors cannot be the input into the neural network. This is because the word embeddings must be <em>part of the neural network</em> so that they can be updated via gradient descent with the other weights. This means that the input to the neural network will actually just be a list of word index's, and this list will correspond to however we decide to build our dictionary. This saves a lot of space, because now we can represent each input by a $Tx1$ vector of integers, rather than a $TxD$ matrix of floats.</p>
<p>From a conceptual standpoint, we are trying to do the following:</p>

<pre><code>word_vectors = []
for index in input_sequence:
    word_vector = We[index, :]
    word_vectors.append(word_vector)
return word_vectors</code></pre>
<p>Here, we are simply taking each word index from the input sequence, grabbing its corresponding word vector, and adding it to a list of word vectors which is the output sequence. Mathematically speaking, the way that you would get a vector is by multiplying the one hot encoded word index vector, by the word embedding matrix:</p>

<pre><code>s = one_hot_encode(input word index) # ex. [0,0,0,...,1,...,0] (1 x V)
x = sW_e # (1 x D)</code></pre>
<p>Above we are taking the dot product of a $1 x V$ vector with a $V x D$ matrix, which will result in a $1 x D$ word vector; exactly what we wanted. Visually, this can be seen below. We have a one hot encoded word, in this case "dog", that has a word index of 147, and our word embedding matrix:</p>
<p><img src="https://drive.google.com/uc?id=1tFHc4IR5iB4QMDxWlsIhyWDqPQPSm0hU" width="550"></p>
<p>We then perform the dot product of our one hot encoded word with the word embedding matrix:</p>
<p><img src="https://drive.google.com/uc?id=1HVpHIQwu-hcRY8jVv4KIRO8XzzRDy1ve" width="400"></p>
<p>We can see that because all entries in the one hot encoded word are zero (besides a 1 at the index 147, representing our dog), our result will be the exact row vector at index 147 of the word embedding matrix. This means that we can skip the computation, and just extract the row specified by our index! This would be trivial in numpy: <code>W_e[147]</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="5.-Generating-Poetry">5. Generating Poetry<a class="anchor-link" href="#5.-Generating-Poetry">&#182;</a></h1><p>We are now going to dive into an interesting use case of an RNN: poetry generation. This is an unsupervised model, and as we discussed in the previous section, the softmax output will be the probability of the next word, given the previous sequence of words:</p>
<p>$$p\big( w_t \mid w_{t-1}, w_{t-2},...,w_0\big)$$</p>
<p>For this first iteration, we will also create an initial word distribution which we will call $\pi$. $\pi$ is just the distribution across all words that line in our poetry will start with a particular word:</p>
<p>$$\pi = p\big( w_0 \big)$$</p>
<p>We will sample from $\pi$ so that each line can start with a different word. The reason for doing this is so that we can generate different sequences. If we consistently had the same start token for input into our recurrent net, it would always output the same prediction (because neural network output is <strong>deterministic</strong>), and then it would put those two tokens into the recurrent net, and so on. Our predictions will take the form:</p>

<pre><code>w0 = rnn.predict(START)
w1 = rnn.predict(w0, START)
w2 = rnn.predict(w0, w1, START)
# and so on...</code></pre>
<p>Remember, the prediction of a neural network is just the argmax of the softmax:</p>
<p>$$w_t = argmax\Big(softmax \big(f(w_{t-1}, w_{t-2}, ...)\big)\Big)$$</p>
<p>Sampling from the initial word distribution will allow each line to possibly start with a different word, which in turn will allow us to generate different sequences.</p>
<h2 id="5.1-Word-Embeddings">5.1 Word Embeddings<a class="anchor-link" href="#5.1-Word-Embeddings">&#182;</a></h2><p>Because we are dealing with a language model, we will also need word embeddings. This means that this RNN will be slightly different than the one we had built for the parity problem. The first difference is that it is going to take, in addition to the hidden layer size, $M$, the dimensionality of the word embeddings, $D$, and the vocabularly size $V$, since the word embedding matrix, $W_e$, needs to be of size $V x D$.</p>
<p>The second difference is that our <code>fit</code> function will only take in $X$, because there are no targets:</p>

<pre><code>rnn.fit(X)</code></pre>
<p>Within the <code>fit</code> function, however, we will create our own targets. The targets for word one to $t-1$, should be the word at time $t$:</p>
<table>
<thead><tr>
<th>Input:</th>
<th>START</th>
<th>$x_0$</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$x_3$</th>
</tr>
</thead>
<tbody>
<tr>
<td>Target:</td>
<td>$x_0$</td>
<td>$x_1$</td>
<td>$x_2$</td>
<td>$x_3$</td>
<td>END</td>
</tr>
</tbody>
</table>
<p>We will need to predict the end of the sequence, however, or else we would just go on creating an infinite line. To do this, we will make the target of the full sequence the <code>END</code> token. Similarly, we will add a <code>START</code> token at the beginning of an input sequence and its target will be the first word. To summarize, the input sequence will be prepended with the <code>START</code> token, and the output sequence will be appended with the <code>END</code> token.</p>
<h2 id="5.2-Accuracy">5.2 Accuracy<a class="anchor-link" href="#5.2-Accuracy">&#182;</a></h2><p>Unlike the parity problem, we want to measure accuracy not simply by the last word, but by every predicted word. Due to that, we will accumulate the number of correct words guessed, and divide it by the total number of words, in order to get the final accuracy:</p>
<p>$$Accuracy = \frac{\text{words correctly guessed}}{\text{sum(len(sentence) + 1 for sentence in sentences})}$$</p>
<h2 id="5.3-Load-and-Save">5.3 Load and Save<a class="anchor-link" href="#5.3-Load-and-Save">&#182;</a></h2><p>Additionally, because we may want to generate new poetry without having to retrain the model every time, we will want to save our model after it is trained, and also have a way to load said model. The API to do so is shown below:</p>

<pre><code>rnn = SimpleRNN.load(filename)
rnn.save(filename)</code></pre>
<p>Note that the first method (<code>load</code>) is a <strong>static</strong> method, and the second method (<code>save</code>) is an instance method. Because theano functions need to be compiled, we can't just set the weights to saved numpy arrays. We must reinitialize the object with all of the required theano functions in order to make predictions.</p>
<h2 id="5.4-The-Data">5.4 The Data<a class="anchor-link" href="#5.4-The-Data">&#182;</a></h2><p>Now, the data that we are going to be dealing with is a collection of Robert Frost poems; about 1500 lines. Each line is a separate sequence. We will perform preprocessing that consists of:</p>
<ul>
<li>Lowercasing all text, removing punctuation, split by whitespace and gather tokens</li>
<li>Give each token an index in <code>word2idx</code> map. Indexes start from 0 and increment by 1</li>
<li>Save each sentence as a sequence of word indexes</li>
<li>Return sentences and <code>word2idx</code> map</li>
</ul>
<p>This is generally the same process that we will follow for building any language model. However, we will see how we can introduce more modifications when we look at more complicated data.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[&nbsp;]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span>
</pre></div>

</div>
</div>
</div>

</div>
<hr>
&copy; 2018 Nathaniel Dake

</div>
</div>
</body>
</html>
